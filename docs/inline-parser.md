# 인라인 파서 (Inline Parser)

인라인 파서는 리프 블록(Leaf Block) 내의 텍스트 콘텐츠를 분석하여 강조(Emphasis), 강한 강조(Strong), 링크(Link), 이미지(Image), 인라인 코드(Inline Code) 등의 요소를 추출하는 역할을 합니다. 이 문서는 `src/inline-parser.ts`에 구현된 인라인 파싱 알고리즘과 주요 기능을 상세히 설명합니다.

## 개요

인라인 파싱은 블록 파싱이 완료된 후, 각 블록의 텍스트 내용을 대상으로 수행됩니다. 주요 특징은 다음과 같습니다:
- **구분자 스택(Delimiter Stack)**을 사용하여 중첩된 강조 및 강한 강조를 처리합니다.
- **CommonMark 사양**을 준수하여 좌우 플랭킹(Flanking) 규칙을 적용합니다.
- **참조 맵(ReferenceMap)**을 사용하여 참조 스타일 링크와 이미지를 해석합니다.
- 이스케이프 시퀀스 및 HTML 엔티티 디코딩을 지원합니다.

## 구분자 스택 알고리즘 (Delimiter Stack Algorithm)

강조(`*`, `_`)와 강한 강조(`**`, `__`)를 정확하게 처리하기 위해 구분자 스택 알고리즘을 사용합니다. 이는 단순히 정규표현식으로 처리하기 어려운 중첩 구조와 복잡한 우선순위를 해결합니다.

### Delimiter 인터페이스
각 구분자는 다음과 같은 정보를 가집니다:
```typescript
interface Delimiter {
  type: '*' | '_';      // 구분자 타입
  count: number;        // 남은 구분자 개수
  originalCount: number; // 원래 구분자 개수
  position: number;     // nodes 배열에서의 위치
  canOpen: boolean;     // 여는 구분자가 될 수 있는지 여부
  canClose: boolean;    // 닫는 구분자가 될 수 있는지 여부
  active: boolean;      // 활성화 상태
}
```

### 처리 과정
1. **스캔 단계**: 텍스트를 순회하며 `*` 또는 `_`를 만나면 `Delimiter` 객체를 생성하여 스택에 추가하고, `nodes` 배열에는 임시 텍스트 노드를 삽입합니다.
2. **분석 단계**: 모든 텍스트 순회가 끝나면 `processEmphasis` 함수를 호출하여 스택을 분석합니다.
3. **매칭 단계**: 닫는 구분자(`canClose`)를 찾으면, 그보다 앞에 있는 적절한 여는 구분자(`canOpen`)를 검색합니다.
4. **변환 단계**: 일치하는 쌍을 찾으면 `useCount`(1 또는 2)만큼 구분자 개수를 차감하고, 사이의 노드들을 `emphasis` 또는 `strong` 노드의 자식으로 묶습니다.
5. **비활성화**: 매칭된 여는 구분자와 닫는 구분자 사이의 모든 구분자들은 `active` 상태를 `false`로 변경하여 이후 매칭에서 제외합니다.

## 강조 매칭 규칙 (Emphasis Matching Rules)

CommonMark 사양에 따라 강조는 매우 엄격한 규칙을 따릅니다.

### 플랭킹(Flanking) 규칙
구분자가 여는 역할이나 닫는 역할을 할 수 있는지 결정하기 위해 좌우 문맥을 확인합니다.
- **Left-flanking**: 뒤에 공백이 아니고, (뒤에 문장 부호가 아니거나 앞에 공백/문장 부호인 경우)
- **Right-flanking**: 앞에 공백이 아니고, (앞에 문장 부호가 아니거나 뒤에 공백/문장 부호인 경우)

특히 `_` 구분자는 단어 중간에서 강조가 시작되거나 끝나는 것을 방지하기 위해 추가적인 영숫자(Alphanumeric) 체크를 수행합니다. `_`가 여는 구분자가 되려면 앞 문자가 영숫자가 아니어야 하며, 닫는 구분자가 되려면 뒤 문자가 영숫자가 아니어야 합니다.

### 3의 배수 규칙 (Rule of 3)
`***`와 같이 구분자가 겹쳐 있을 때, 여는 구분자와 닫는 구분자의 합이 3의 배수이면 특별한 규칙이 적용됩니다. 두 구분자 중 하나라도 여는 동시에 닫는 역할(`canOpen && canClose`)을 할 수 있는 경우, 각각의 원래 개수가 3의 배수가 아니라면 서로 매칭되지 않습니다. 이는 `***strong emphasis***`와 같은 복잡한 케이스를 정확하게 처리하기 위함입니다.

## 링크 및 이미지 파싱

링크와 이미지는 `parseLinkOrImage` 함수에서 처리되며, 인라인 스타일과 참조 스타일을 모두 지원합니다.

### 인라인 스타일 (Inline Style)
`[text](url "title")` 형식을 파싱합니다.
- `parseDestination`: URL 부분을 추출하며, 괄호 쌍(`(...)`)이나 `<...>` 형식을 지원합니다. 백슬래시 이스케이프도 처리합니다.
- `parseTitle`: 선택적인 타이틀 부분을 추출합니다. (`"..."`, `'...'`, `(...)` 지원)

### 참조 스타일 (Reference Style)
`[text][label]` 또는 `[text][]`, `[text]` 형식을 지원합니다.
- **ReferenceMap**: 블록 파싱 단계에서 수집된 참조 정의들을 담고 있는 맵입니다.
- **식별자 해결**: `label` 또는 `text`를 소문자로 변환하고 연속된 공백을 하나로 정규화하여 `ReferenceMap`에서 검색합니다.
- 검색 성공 시 해당 참조의 URL과 타이틀을 사용하여 `link` 또는 `image` 노드를 생성합니다.

## 기타 인라인 요소 처리

### 인라인 코드 (Code Spans)
백틱(`` ` ``)으로 감싸진 텍스트를 처리합니다.
- 여는 백틱의 개수와 동일한 개수의 닫는 백틱을 찾습니다.
- 내부의 줄바꿈은 공백으로 치환됩니다.
- 앞뒤에 공백이 하나씩 있고 내부 콘텐츠가 비어있지 않다면, 해당 공백들은 제거됩니다 (예: `` `  code  ` `` -> ` code `).

### 이스케이프 및 엔티티 (Escapes & Entities)
- **이스케이프**: 백슬래시(`\`) 뒤에 오는 특수 문장 부호들을 일반 문자로 취급합니다. `ESCAPABLE` 상수에 정의된 32개의 문자들만 이스케이프 가능합니다.
- **HTML 엔티티**: `&amp;`, `&lt;`와 같은 명명된 엔티티와 `&#123;`, `&#x7B;`와 같은 숫자 엔티티를 디코딩합니다. `decodeEntity` 함수가 이 로직을 담당합니다.

### 줄바꿈 (Line Breaks)
- **Hard Line Break**: 줄 끝에 두 개 이상의 공백이 있거나, 백슬래시(`\`) 뒤에 바로 줄바꿈이 오는 경우 `break` 노드를 생성합니다.
- **Soft Line Break**: 일반적인 줄바꿈은 하나의 공백으로 처리되어 텍스트 노드에 포함됩니다.

## 위치 추적 (Position Tracking)

모든 인라인 노드는 선택적으로 `position` 정보를 가질 수 있습니다. `parseInline` 함수는 `startPosition`을 인자로 받아 각 노드의 정확한 시작 및 종료 위치(행, 열, 오프셋)를 계산할 수 있는 기반을 제공합니다. 이는 에디터나 린터와 같은 도구에서 소스 코드와의 연결성을 유지하는 데 필수적입니다.

## 요약

인라인 파서는 단순한 문자열 처리를 넘어 CommonMark의 복잡한 사양을 충실히 구현합니다. 델리미터 스택을 통한 강조 처리, 정규화된 참조 해결, 그리고 정교한 이스케이프 로직을 통해 사용자에게 일관되고 정확한 마크다운 파싱 결과를 제공합니다.
