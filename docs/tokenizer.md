# 라인 기반 토크나이저 (Line-based Tokenizer)

이 문서는 Markdown 파서의 첫 번째 단계인 라인 기반 토크나이저의 구현 상세와 동작 방식을 설명합니다. 토크나이저는 입력된 Markdown 텍스트를 라인 단위로 분석하여 구조적 정보를 담은 토큰 배열로 변환하는 역할을 수행합니다.

## 1. 개요

토크나이저는 전체 Markdown 문서를 한 번에 처리하는 대신, 라인 단위로 쪼개어 각 라인의 성격을 규명합니다. 이는 CommonMark 사양에서 정의하는 블록 구조 분석을 위한 기초 데이터를 제공합니다. 토크나이저는 단순히 텍스트를 나누는 것에 그치지 않고, 탭 확장, 들여쓰기 계산, 위치 정보 추적 등 복합적인 작업을 수행합니다.

## 2. 라인 기반 토큰화 개념

Markdown은 기본적으로 라인 중심의 언어입니다. 제목, 목록, 인용구 등 대부분의 블록 요소는 라인의 시작 부분에 나타나는 특정 패턴에 의해 결정됩니다. 본 파서의 토크나이저는 다음과 같은 과정을 거칩니다.

1. 입력 문자열을 라인 엔딩(`\n`, `\r\n`, `\r`)을 기준으로 분리합니다.
2. 각 라인에 대해 탭 문자를 공백으로 확장합니다.
3. 라인의 들여쓰기 수준을 계산합니다.
4. 정규 표현식을 사용하여 라인의 유형(LineType)을 분류합니다.
5. 위치 정보(행 번호, 오프셋)를 포함한 토큰 객체를 생성합니다.

## 3. 탭 처리 (Tab Handling)

CommonMark 사양에 따라 탭 문자는 4자 단위의 탭 정지(Tab Stop)를 기준으로 공백으로 변환됩니다. 이는 단순히 탭 하나를 공백 4개로 바꾸는 것이 아니라, 현재 컬럼 위치에 따라 1개에서 4개의 공백으로 가변적으로 확장됨을 의미합니다.

### expandTabs 함수 동작 방식
`expandTabs` 함수는 라인을 순회하며 다음 로직을 적용합니다.
- 탭 문자(`\t`)를 만나면: `4 - ((현재 컬럼 - 1) % 4)` 만큼의 공백을 추가합니다.
- 일반 문자를 만나면: 문자를 그대로 유지하고 컬럼을 1 증가시킵니다.
- 들여쓰기 계산: 라인 시작부터 첫 번째 비공백 문자가 나오기 전까지의 확장된 공백 개수를 `indent` 값으로 기록합니다.

이러한 처리는 이후 '들여쓰기 코드 블록(Indented Code Block)'이나 목록의 중첩 구조를 판별할 때 매우 중요하게 작용합니다. 본 파서는 탭을 단순히 공백 4개로 치환하지 않고, 실제 탭 정지 위치를 계산하여 정확한 시각적 들여쓰기를 재현합니다.

## 4. 위치 추적 (Position Tracking)

정확한 에디터 지원 및 오류 보고를 위해 토크나이저는 각 라인의 위치 정보를 엄격하게 관리합니다.

- **lineNumber**: 1부터 시작하는 행 번호입니다.
- **offset**: 입력 문자열의 시작점으로부터 해당 라인이 시작되는 지점까지의 0부터 시작하는 바이트 오프셋입니다.

이 정보는 이후 AST 노드의 `position` 속성으로 전파되어, 최종 결과물에서도 원본 소스의 위치를 참조할 수 있게 합니다. 컬럼 정보는 `expandTabs` 과정에서 계산된 값을 바탕으로 인라인 파싱 단계에서 정교화됩니다.

## 5. 토큰 인터페이스 (Token Interface)

토크나이저가 생성하는 `Token` 객체는 다음과 같은 구조를 가집니다.

```typescript
export interface Token {
  type: LineType;          // 라인의 분류 유형
  raw: string;             // 라인 엔딩을 제외한 원본 문자열
  content: string;         // 마커 등을 제외한 실제 내용물
  lineNumber: number;      // 1부터 시작하는 행 번호
  offset: number;          // 0부터 시작하는 시작 오프셋
  indent: number;          // 탭 확장 후의 선행 공백 개수
  headingLevel?: number;   // 제목 수준 (1-6)
  setextLevel?: number;    // Setext 제목 수준 (1-2)
  listType?: 'bullet' | 'ordered'; // 목록 유형
  listStart?: number;      // 순서 있는 목록의 시작 번호
  listMarker?: string;     // 목록 마커 문자열
  fenceChar?: string;      // 코드 펜스 문자 (` 또는 ~)
  fenceLength?: number;    // 코드 펜스 길이
  codeLang?: string;       // 코드 블록 언어 식별자
}
```

## 6. 라인 유형 (LineType) 및 분류 규칙

각 라인은 `classifyLine` 함수를 통해 다음 중 하나의 유형으로 분류됩니다. 분류는 우선순위에 따라 순차적으로 진행됩니다.

### 1. blank (빈 줄)
- 패턴: 공백이나 탭으로만 구성된 라인 또는 완전히 비어 있는 라인입니다.
- 용도: 블록 요소 간의 구분자로 사용되며, 목록이나 인용구의 끝을 알리는 신호가 되기도 합니다.

### 2. indentedCode (들여쓰기 코드)
- 조건: 들여쓰기 수준(`indent`)이 4 이상인 경우입니다.
- 특징: 다른 블록 요소(제목, 목록 등)보다 우선순위가 낮을 수 있으나, 토크나이저 단계에서는 일차적으로 분류됩니다.

### 3. atxHeading (ATX 제목)
- 패턴: 1개에서 6개의 `#` 문자로 시작하고 공백이 뒤따르는 형태입니다.
- 속성: `headingLevel`에 `#`의 개수가 저장되며, 라인 끝의 닫는 `#` 문자들은 제거됩니다.

### 4. thematicBreak (가로 구분선)
- 패턴: `-`, `*`, `_` 문자가 3개 이상 나열된 형태입니다. 문자 사이에 공백이 포함될 수 있습니다.

### 5. setextUnderline (Setext 제목 밑줄)
- 패턴: `=` 또는 `-` 문자로만 구성된 라인입니다.
- 용도: 바로 앞 라인을 제목으로 격상시킵니다. `=`는 Level 1, `-`는 Level 2 제목을 의미합니다.

### 6. listMarker (목록 마커)
- 패턴: `-`, `+`, `*` (글머리 기호) 또는 `1.`, `1)` (순서 번호) 형태입니다.
- 속성: `listType`, `listStart`, `listMarker` 등이 포함되어 목록의 성격을 정의합니다.

### 7. blockquoteMarker (인용구 마커)
- 패턴: `>` 문자로 시작하는 형태입니다. 뒤에 선택적으로 공백 하나가 올 수 있습니다.

### 8. codeFence (코드 펜스)
- 패턴: ``` 또는 ~~~ 로 시작하는 라인입니다.
- 속성: `fenceChar`, `fenceLength`, `codeLang` 정보가 추출되어 코드 블록의 시작과 끝을 식별합니다.

### 9. paragraph (단락)
- 패턴: 위의 어떤 유형에도 해당하지 않는 일반적인 텍스트 라인입니다.

### 10. other (기타)
- 패턴: 위의 어떤 유형에도 해당하지 않는 예외적인 라인입니다.
- 용도: 분류할 수 없는 상황을 처리하기 위한 폴백 유형입니다.

## 7. 토큰화 예시

다음과 같은 Markdown 입력이 있다고 가정해 봅시다.

```markdown
# 제목
  - 목록 항목
```

이 입력은 다음과 같은 토큰 배열로 변환됩니다.

**첫 번째 라인:**
- type: 'atxHeading'
- raw: '# 제목'
- content: '제목'
- lineNumber: 1
- indent: 0
- headingLevel: 1

**두 번째 라인:**
- type: 'listMarker'
- raw: '  - 목록 항목'
- content: '목록 항목'
- lineNumber: 2
- indent: 2
- listType: 'bullet'
- listMarker: '-'

이와 같이 토크나이저는 복잡한 Markdown 문서를 정형화된 데이터 구조로 변환하여, 이후 블록 파서가 문서의 계층 구조를 파악할 수 있도록 돕습니다. 각 토큰은 독립적인 라인 정보를 담고 있으며, 블록 파서는 이 토큰들을 조합하여 최종적인 문서 트리를 구성하게 됩니다.
