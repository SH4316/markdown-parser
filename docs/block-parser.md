# 블록 파서 (Block Parser)

블록 파서는 Markdown 텍스트를 라인 단위로 분석하여 블록 레벨의 구조를 형성하는 역할을 합니다. 이 문서는 `src/block-parser.ts`의 구현 방식과 주요 개념을 설명합니다.

## 블록 파싱의 개념과 목적

블록 파싱은 Markdown 파싱의 첫 번째 단계 중 하나로, 텍스트를 제목, 단락, 목록, 인용구와 같은 큰 덩어리(블록)로 나누는 과정입니다. 블록 파서의 주요 목적은 다음과 같습니다.

1. 라인 단위 토큰을 구조화된 블록 노드로 변환합니다.
2. 블록 간의 계층 구조(예: 목록 내의 단락)를 형성합니다.
3. 각 블록의 정확한 위치 정보(행, 열, 오프셋)를 계산합니다.
4. 문서 전체에서 사용되는 링크 참조 정의(Link Reference Definitions)를 수집합니다.

## 컨테이너 블록 vs 리프 블록

CommonMark 사양에 따라 블록은 크게 두 가지 유형으로 나뉩니다. 이 구분은 파싱 로직에서 매우 중요한 역할을 합니다.

### 컨테이너 블록 (Container Blocks)
다른 블록을 자식으로 포함할 수 있는 블록입니다. 이러한 블록들은 재귀적으로 파싱됩니다.
- **Blockquote (인용구)**: `>` 문자로 시작하며 내부에 다른 블록들을 포함할 수 있습니다.
- **List (목록)**: 순서가 있거나 없는 목록으로, 여러 개의 `ListItem`을 자식으로 가집니다.
- **ListItem (목록 항목)**: 목록의 개별 항목으로, 내부에 단락이나 다른 목록을 포함할 수 있습니다.

### 리프 블록 (Leaf Blocks)
다른 블록을 포함할 수 없고, 텍스트 내용(인라인 콘텐츠)만을 포함하는 블록입니다.
- **Heading (제목)**: ATX 스타일(`#`) 또는 Setext 스타일(`===`, `---`)의 제목입니다.
- **Paragraph (단락)**: 일반적인 텍스트 덩어리입니다.
- **Code (코드 블록)**: 펜스(```) 또는 들여쓰기로 구분된 코드 블록입니다.
- **ThematicBreak (가로 구분선)**: `---`, `***`, `___` 등으로 표현되는 구분선입니다.

## 재귀적 하강 파싱 접근 방식

`parseBlocks()` 함수는 토큰 배열을 순차적으로 처리하면서 블록을 생성합니다. 컨테이너 블록의 경우, 내부 콘텐츠를 다시 `parseBlocks()`에 전달하여 재귀적으로 처리하는 방식을 취합니다.

1. `tokenize()`를 통해 입력 문자열을 라인 단위 토큰으로 변환합니다.
2. 토큰 배열을 처음부터 끝까지 순회합니다.
3. 현재 토큰의 유형에 따라 적절한 블록 생성 로직을 실행합니다.
4. 컨테이너 블록(인용구, 목록 항목)을 만나면 해당 블록에 속하는 토큰들을 수집합니다.
5. 수집된 토큰들의 `content`를 합쳐 새로운 문자열을 만들고, `parseBlocks()`를 재귀적으로 호출하여 자식 노드들을 생성합니다.

## 주요 블록 유형별 파싱 로직

### 제목 (Heading)
- **ATX Heading**: 토큰의 `headingLevel`을 사용하여 `depth`를 결정합니다. `#`의 개수에 따라 1부터 6까지의 깊이를 가집니다.
- **Setext Heading**: 단락 뒤에 오는 `setextUnderline` 토큰을 감지하여 제목으로 변환합니다. `=`는 레벨 1, `-`는 레벨 2 제목이 됩니다.

### 단락 (Paragraph)
- 연속된 텍스트 라인들을 하나의 단락으로 묶습니다.
- 다른 블록의 시작(제목, 목록 등)이나 빈 라인을 만나면 단락이 종료됩니다.
- 단락 내의 텍스트는 나중에 인라인 파서에 의해 처리될 수 있도록 `rawText` 속성에 보관됩니다.

### 코드 블록 (Code Block)
- **Fenced Code**: 시작 펜스와 일치하는 종료 펜스를 찾을 때까지의 모든 라인을 수집합니다. 펜스 문자는 백틱(```) 또는 물결표(~~~)가 사용될 수 있습니다.
- **Indented Code**: 4개 이상의 공백으로 들여쓰기된 라인들을 수집합니다. 빈 라인이 중간에 섞여 있어도 후속 라인이 들여쓰기되어 있다면 하나의 코드 블록으로 유지됩니다.

### 인용구 (Blockquote)
- `>` 마커로 시작하는 라인들을 수집합니다.
- CommonMark의 "Lazy Continuation" 규칙에 따라 마커가 없는 후속 라인도 단락의 일부라면 인용구에 포함될 수 있습니다.

### 목록 (List)
- 동일한 유형의 목록 마커를 가진 항목들을 하나의 목록으로 묶습니다.
- 목록 항목 사이에 빈 라인이 있는지 여부에 따라 `spread` 속성(Loose vs Tight)을 결정합니다.
- `spread`가 `true`인 경우(Loose List), 목록 항목 내의 단락들은 `p` 태그로 감싸지는 것과 유사한 효과를 가집니다.

## 링크 참조 정의 처리 (Link Reference Definition)

단락이 단일 라인이고 특정 패턴(`[label]: url "title"`)과 일치하는 경우, 이를 일반 단락으로 처리하지 않고 링크 참조 정의로 처리합니다.

- **정규식 패턴**: `^\[([^\]]+)\]:\s*<?([^\s>]+)>?(?:\s+["'(]([^"')]+)["')])?$`
- 추출된 식별자(identifier)는 대소문자를 구분하지 않으며, 연속된 공백은 하나로 정규화됩니다.
- 수집된 정의는 `ReferenceMap`에 저장되어 이후 인라인 파싱 단계에서 링크 노드를 생성할 때 사용됩니다.

## 위치 계산 (Position Calculation)

모든 노드는 `position` 속성을 통해 소스 코드에서의 위치를 나타냅니다. 이는 에디터 지원이나 에러 보고에 필수적입니다.

- `start`: 블록이 시작되는 첫 번째 토큰의 시작 지점입니다.
- `end`: 블록이 끝나는 마지막 토큰의 끝 지점입니다.
- 각 지점은 `line`(1부터 시작), `column`(1부터 시작), `offset`(0부터 시작) 정보를 포함합니다.
- `makePoint`와 `makePosition` 헬퍼 함수가 이 계산을 담당합니다.

## ReferenceMap 구축

`parseBlocks()`의 결과물인 `BlockParseResult`에는 AST의 루트 노드뿐만 아니라 `references` 맵도 포함됩니다.

- 이 맵은 문서 내의 모든 링크 참조 정의를 담고 있습니다.
- 재귀적인 파싱 과정에서 하위 블록(인용구 등)에서 발견된 참조 정의들도 최상위 맵으로 병합됩니다.
- 최종적으로 이 맵은 `parseInline()` 함수에 전달되어 `[text][ref]`와 같은 참조 스타일 링크를 해석하는 데 사용됩니다.

## 구현 세부 사항 및 헬퍼 함수

- `collectParagraphTokens`: 단락을 구성하는 연속된 토큰들을 수집합니다.
- `collectIndentedCodeTokens`: 들여쓰기된 코드 블록 토큰들을 수집합니다.
- `collectFencedCodeTokens`: 펜스 코드 블록 토큰들을 수집합니다.
- `collectBlockquoteTokens`: 인용구 토큰들을 수집합니다.
- `collectListTokens`: 목록과 목록 항목 토큰들을 수집하며 `isLoose` 상태를 판별합니다.

이러한 구조화된 접근 방식을 통해 복잡한 중첩 구조를 가진 Markdown 문서도 정확하고 효율적으로 파싱할 수 있습니다.
