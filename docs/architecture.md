# Markdown Parser 아키텍처 설계 문서

이 문서는 TypeScript로 구현된 Markdown 파서의 전체적인 아키텍처와 데이터 흐름을 설명합니다. 본 파서는 CommonMark 사양을 준수하며, 최종적으로 MDAST(Markdown Abstract Syntax Tree) 호환 구조를 생성하는 것을 목표로 합니다.

## 1. 개요

본 파서는 복잡한 Markdown 문법을 효율적으로 처리하기 위해 2단계 파싱 전략(Two-stage parsing)을 채택하고 있습니다. 먼저 문서의 전체적인 구조인 블록 요소를 파악한 후, 각 블록 내부의 텍스트를 분석하여 인라인 요소를 처리합니다.

## 2. 파싱 파이프라인

전체 파싱 과정은 다음과 같은 단계로 구성됩니다.

### 2.1. 토크나이저 (Tokenizer)
입력된 Markdown 문자열을 라인 단위로 분석하여 토큰화합니다.
- 입력: Markdown 문자열
- 출력: 라인 토큰 배열 (Token[])
- 역할: 각 라인의 특성(제목, 목록 시작, 인용구 등)을 파악하고 위치 정보(행, 열, 오프셋)를 계산합니다.

### 2.2. 블록 파서 (Block Parser)
토크나이저가 생성한 토큰을 바탕으로 문서의 블록 구조를 형성합니다.
- 입력: 라인 토큰 배열
- 출력: 블록 레벨 AST 및 참조 맵 (ReferenceMap)
- 역할:
    - 제목(Heading), 단락(Paragraph), 목록(List), 인용구(Blockquote) 등의 블록 요소를 식별합니다.
    - 컨테이너 블록(목록, 인용구)의 경우 재귀적으로 내부 블록을 파싱합니다.
    - 링크 참조 정의(Link Reference Definitions)를 수집하여 `ReferenceMap`을 생성합니다.
    - 인라인 파싱이 필요한 텍스트는 `rawText` 속성에 임시로 저장합니다.

### 2.3. 인라인 파서 (Inline Parser)
블록 파싱이 완료된 후, 각 블록 내부의 텍스트를 분석하여 인라인 요소를 처리합니다.
- 입력: 원문 텍스트 및 참조 맵
- 출력: 인라인 노드 배열 (PhrasingContent[])
- 역할:
    - 강조(Emphasis), 강한 강조(Strong), 링크(Link), 이미지(Image), 인라인 코드(InlineCode) 등을 식별합니다.
    - 델리미터 스택(Delimiter Stack) 알고리즘을 사용하여 중첩된 강조 구문을 처리합니다.
    - 블록 단계에서 수집된 `ReferenceMap`을 사용하여 참조 링크를 실제 URL로 변환합니다.

## 3. 데이터 흐름 및 변환

데이터는 다음과 같은 경로를 통해 변환됩니다.

1. **String to Tokens**: 원문 문자열이 토크나이저를 거쳐 라인 단위 토큰으로 변환됩니다.
2. **Tokens to Block Tree**: 토큰들이 블록 파서를 통해 트리 구조를 형성합니다. 이때 텍스트 내용은 아직 파싱되지 않은 상태입니다.
3. **Block Tree to Final AST**: `src/index.ts`의 `processNode` 함수가 트리를 순회하며 각 노드의 `rawText`를 인라인 파서로 전달합니다. 인라인 파서의 결과물이 해당 노드의 자식(children)으로 대체되면서 최종적인 MDAST가 완성됩니다.

## 4. 참조 맵 (ReferenceMap) 전달

Markdown에서는 문서의 어느 곳에서나 링크 참조를 정의할 수 있습니다. 이를 처리하기 위해 블록 파싱 단계에서 모든 참조 정의를 수집하여 `Map<string, { url: string, title?: string }>` 형태의 `ReferenceMap`을 만듭니다. 이 맵은 인라인 파싱 단계로 전달되어 `[label][id]` 형태의 참조 링크를 해석하는 데 사용됩니다.

## 5. 위치 추적 (Position Tracking)

모든 노드는 소스 코드 내에서의 정확한 위치 정보를 유지합니다.
- `start`: 노드가 시작되는 지점 (line, column, offset)
- `end`: 노드가 끝나는 지점 (line, column, offset)

토크나이저 단계에서 계산된 위치 정보는 블록 파서를 거쳐 최종 AST 노드까지 전달됩니다. 이는 에디터의 구문 강조나 오류 보고 등에서 유용하게 활용됩니다.

## 6. 아키텍처 다이어그램

```text
+-----------------------------------------------------------+
|                    Input Markdown String                  |
+-----------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------+
|                       Tokenizer                           |
|  (Line-by-line analysis, Position calculation)            |
+-----------------------------------------------------------+
                              |
                              | Tokens (Token[])
                              v
+-----------------------------------------------------------+
|                     Block Parser                          |
|  (Identify Block Structures: Headings, Lists, etc.)       |
|  (Collect Link Reference Definitions)                     |
+-----------------------------------------------------------+
                              |
                              | Block Tree + ReferenceMap
                              v
+-----------------------------------------------------------+
|                    Integration Layer                      |
|  (Recursive Tree Traversal via processNode)               |
+-----------------------------------------------------------+
                              |
               +--------------+--------------+
               |                             |
               v                             v
+---------------------------+   +---------------------------+
|      Inline Parser        |   |      ReferenceMap         |
|  (Emphasis, Links, etc.)  | <--- (URL/Title Lookup)       |
+---------------------------+   +---------------------------+
               |
               v
+-----------------------------------------------------------+
|                    Final MDAST Tree                       |
|  (Root node with fully parsed children)                   |
+-----------------------------------------------------------+
```

## 7. 주요 모듈 설명

- `src/types.ts`: MDAST 사양에 기반한 모든 노드의 타입 정의를 포함합니다.
- `src/tokenizer.ts`: 정규 표현식을 사용하여 각 라인의 유형을 빠르게 분류합니다.
- `src/block-parser.ts`: 상태 기반의 로직을 사용하여 복잡한 블록 구조(특히 중첩된 목록)를 처리합니다.
- `src/inline-parser.ts`: 문자 단위 스캔과 스택 기반 알고리즘을 결합하여 인라인 요소를 파싱합니다.
- `src/index.ts`: 전체 파이프라인을 조율하고 외부 API를 제공합니다.

## 8. 결론

이러한 계층적 구조는 파서의 유지보수성을 높이고 각 단계의 책임을 명확히 분리합니다. 블록 구조와 인라인 구조를 분리하여 처리함으로써 CommonMark의 복잡한 규칙들을 보다 체계적으로 구현할 수 있으며, 최종적으로 표준화된 MDAST 형식을 제공하여 생태계 내의 다른 도구들과 원활하게 협업할 수 있는 기반을 마련합니다.
